{"version":3,"file":"methodCache.js","sourceRoot":"","sources":["../../src/lib/methodCache.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,GAAG,MAAM,WAAW,CAAA;AAC3B,OAAO,EAAE,MAAM,EAAE,MAAM,OAAO,CAAA;AAE9B,yEAAyE;AACzE,MAAM,CAAC,IAAI,QAAa,CAAA;AACxB,MAAM,CAAC,MAAM,OAAO,GAAwC,IAAI,GAAG,EAAE,CAAA;AACrE,MAAM,CAAC,MAAM,QAAQ,GAAgB;IACnC,GAAG,EAAE,GAAG;IACR,MAAM,EAAE,GAAG,GAAG,IAAI;CACnB,CAAA;AAED;;;GAGG;AACH,MAAM,UAAU,GAAG,CAAE,aAAqB;IACxC,QAAQ,GAAG,aAAa,CAAA;AAC1B,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,MAAM,CAAE,MAAc,EAAE,UAAuB,EAAE;IAC/D,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAA;IAC1C,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,GAAG,CAAC,OAAO,CAAC,CAAC,CAAA;IACrC,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;AAC5B,CAAC;AAED;;;;GAIG;AACH,MAAM,CAAC,KAAK,UAAU,IAAI,CAAE,MAAc,EAAE,GAAW;IACrD,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;QAAE,MAAM,CAAC,MAAM,CAAC,CAAA,CAAC,mBAAmB;IAC5D,MAAM,WAAW,GAAG,OAAO,CAAC,GAAG,CAAC,MAAM,CAAE,CAAA;IACxC,IAAI,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE;QACxB,MAAM,CAAC,KAAK,CAAC,4BAA4B,MAAM,IAAI,GAAG,GAAG,CAAC,CAAA;QAC1D,0DAA0D;QAC1D,OAAO,WAAW,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;KAC5B;IACD,kDAAkD;IAClD,MAAM,CAAC,KAAK,CAAC,IAAI,MAAM,4BAA4B,MAAM,IAAI,GAAG,GAAG,CAAC,CAAA;IACpE,MAAM,MAAM,GAAG,MAAM,OAAO,CAAC,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC,CAAC,CAAA;IAChE,WAAW,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAA;IAC5B,OAAO,MAAM,CAAA;AACf,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,GAAG,CAAE,MAAc;IACjC,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAA;AAC5B,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,GAAG,CAAE,MAAc,EAAE,GAAW;IAC9C,IAAI,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC;QAAE,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;AAC/D,CAAC;AAED;;;;GAIG;AACH,MAAM,UAAU,KAAK,CAAE,MAAc,EAAE,GAAY;IACjD,IAAI,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,EAAE;QACvB,IAAI,GAAG;YAAE,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC,GAAG,CAAC,GAAG,CAAC,CAAA;;YACxC,OAAO,OAAO,CAAC,GAAG,CAAC,MAAM,CAAE,CAAC,KAAK,EAAE,CAAA;KACzC;AACH,CAAC;AAED,4CAA4C;AAC5C,MAAM,UAAU,QAAQ;IACtB,OAAO,CAAC,OAAO,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,CAAA;AAC3C,CAAC","sourcesContent":["/**\n * @module methodCache\n * Manages results cache for calls to server (via LRU cache)\n */\n\nimport LRU from 'lru-cache'\nimport { logger } from './log'\n\n/** @TODO: Remove ! post-fix expression when TypeScript #9619 resolved */\nexport let instance: any\nexport const results: Map<string, LRU.Cache<string, any>> = new Map()\nexport const defaults: LRU.Options = {\n  max: 100,\n  maxAge: 300 * 1000\n}\n\n/**\n * Set the instance to call methods on, with cached results.\n * @param instanceToUse Instance of a class\n */\nexport function use (instanceToUse: object) {\n  instance = instanceToUse\n}\n\n/**\n * Setup a cache for a method call.\n * @param method Method name, for index of cached results\n * @param options.max Maximum size of cache\n * @param options.maxAge Maximum age of cache\n */\nexport function create (method: string, options: LRU.Options = {}) {\n  options = Object.assign(defaults, options)\n  results.set(method, new LRU(options))\n  return results.get(method)\n}\n\n/**\n * Get results of a prior method call or call and cache.\n * @param method Method name, to call on instance in use\n * @param key Key to pass to method call and save results against\n */\nexport async function call (method: string, key: string) {\n  if (!results.has(method)) create(method) // create as needed\n  const methodCache = results.get(method)!\n  if (methodCache.has(key)) {\n    logger.debug(`[cache] Returning cached ${method}(${key})`)\n    // return from cache if key has been used on method before\n    return methodCache.get(key)\n  }\n  // call and cache for next time, returning results\n  logger.debug(`[${method}] Caching new results of ${method}(${key})`)\n  const result = await Promise.resolve(instance.call(method, key))\n  methodCache.set(key, result)\n  return result\n}\n\n/**\n * Proxy for checking if method has been cached.\n * Cache may exist from manual creation, or prior call.\n * @param method Method name for cache to get\n */\nexport function has (method: string) {\n  return results.has(method)\n}\n\n/**\n * Get results of a prior method call.\n * @param method Method name for cache to get\n * @param key Key for method result set to return\n */\nexport function get (method: string, key: string) {\n  if (results.has(method)) return results.get(method)!.get(key)\n}\n\n/**\n * Reset a cached method call's results (all or only for given key).\n * @param method Method name for cache to clear\n * @param key Key for method result set to clear\n */\nexport function reset (method: string, key?: string) {\n  if (results.has(method)) {\n    if (key) return results.get(method)!.del(key)\n    else return results.get(method)!.reset()\n  }\n}\n\n/** Reset cached results for all methods. */\nexport function resetAll () {\n  results.forEach((cache) => cache.reset())\n}\n"]}