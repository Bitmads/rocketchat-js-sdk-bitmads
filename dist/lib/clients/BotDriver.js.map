{"version":3,"file":"BotDriver.js","sourceRoot":"","sources":["../../../src/lib/clients/BotDriver.ts"],"names":[],"mappings":"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","sourcesContent":["import { Message } from '../message'\nimport { logger } from '../log'\nimport { Protocols } from '../drivers'\nimport Rocketchat from './Rocketchat'\nimport {\n\tILogger,\n\tISocketOptions,\n\tIRespondOptions,\n\tICallback,\n\tIMessageCallback,\n\tISubscriptionEvent,\n\tIMessage,\n\tIMessageMeta,\n\tIMessageReceipt,\n\tISubscription,\n\tICredentials,\n\tILoginResult\n} from '../../interfaces'\n\nconst MY_MESSAGES = '__my_messages__'\n\nexport default class BotDriver extends Rocketchat {\n  integrationId: string\n  lastReadTime: Date = new Date(-8640000000000000)\n  joinedIds: string[] = []\n  messages: ISubscription | null = null\n\n  constructor ({ integrationId, ...config }: any) {\n    super(config)\n    this.integrationId = integrationId\n  }\n\n  async connect (options: ISocketOptions, callback?: ICallback): Promise<any> {\n    try {\n      const result = await this.socket.connect(options)\n      if (callback) {\n        callback(null, result)\n      }\n      return result\n\n    } catch (error) {\n      if (callback) {\n        callback(error, null)\n        return Promise.reject(error)\n      }\n    }\n  }\n\n  async subscribeToMessages () {\n    if (!this.messages) {\n      this.messages = await this.subscribe('stream-room-messages', MY_MESSAGES)\n    }\n    return this.messages\n  }\n\n  async reactToMessages (callback: IMessageCallback) {\n    const handler = (e: ISubscriptionEvent) => {\n      try {\n        const message: IMessage = e.fields.args[0]\n        const meta: IMessageMeta = e.fields.args[1]\n        if (!message || !meta || !message._id || !meta.roomType) {\n          callback(new Error('Message handler fired on event without message or meta data'))\n        } else {\n          callback(null, message, meta)\n        }\n      } catch (err) {\n        this.logger.error(`[driver] Message handler err: ${err.message}`)\n        callback(err)\n      }\n    }\n    this.messages = await this.subscribeToMessages()\n\n    this.messages.onEvent(handler)\n\n    this.logger.info(`[driver] Added event handler for ${this.messages!.name} subscription`)\n  }\n\n  joinRooms (rooms: string[]): Promise<void[]> {\n\t  return Promise.all(rooms.map((rid) => this.joinRoom(rid)))\n  }\n\n  async respondToMessages (callback: IMessageCallback, options: IRespondOptions = {}) {\n    const config = { ...this.config, ...options }\n\n\t\t// Join configured rooms if they haven't been already, unless listening to all\n\t\t// public rooms, in which case it doesn't matter\n    if (!config.allPublic && this.joinedIds.length === 0 && config.rooms && config.rooms.length > 0) {\n      try {\n        await this.joinRooms(config.rooms)\n      } catch (err) {\n        this.logger.error(`[driver] Failed to join configured rooms (${config.rooms.join(', ')}): ${err.message}`)\n      }\n    }\n\n    this.lastReadTime = new Date() // init before any message read\n\n    return this.reactToMessages(async (err, message, meta) => {\n      if (err) {\n        logger.error(`[driver] Unable to receive: ${err.message}`)\n        return callback(err) // bubble errors back to adapter\n      }\n      if (typeof message === 'undefined' || typeof meta === 'undefined') {\n        logger.error(`[driver] Message or meta undefined`)\n        return callback(err)\n      }\n\n\t\t\t// Ignore bot's own messages\n      if (message.u && message.u._id === this.userId) return\n\n\t\t\t// Ignore DMs unless configured not to\n      const isDM = meta.roomType === 'd'\n      if (isDM && !config.dm) return\n\n\t\t\t// Ignore Livechat unless configured not to\n      const isLC = meta.roomType === 'l'\n      if (isLC && !config.livechat) return\n\n\t\t\t// Ignore messages in un-joined public rooms unless configured not to\n      if (!config.allPublic && !isDM && !meta.roomParticipant) return\n\n\t\t\t// Set current time for comparison to incoming\n      let currentReadTime = (message.ts) ? new Date(message.ts.$date) : new Date()\n\n\t\t\t// Ignore edited messages if configured to\n      if (!config.edited && typeof message.editedAt !== 'undefined') return\n\n\t\t\t// Ignore messages in stream that aren't new\n      if (currentReadTime <= this.lastReadTime) return\n\n\t\t\t// At this point, message has passed checks and can be responded to\n      const username = (message.u) ? message.u.username : 'unknown'\n      logger.info(`[driver] Message ${message._id} from ${username}`)\n      this.lastReadTime = currentReadTime\n      callback(null, message, meta)\n    })\n  }\n/**\n * Prepare and send string/s to specified room ID.\n * @param content Accepts message text string or array of strings.\n * @param roomId  ID of the target room to use in send.\n * @todo Returning one or many gets complicated with type checking not allowing\n *       use of a property because result may be array, when you know it's not.\n *       Solution would probably be to always return an array, even for single\n *       send. This would be a breaking change, should hold until major version.\n */\n  sendToRoomId (\n\tcontent: string | string[] | IMessage,\n\troomId: string\n): Promise<IMessageReceipt[] | IMessageReceipt> {\n    if (Array.isArray(content)) {\n      return Promise.all(content.map((text) => {\n        return this.sendMessage(this.prepareMessage(text, roomId)) as Promise<IMessageReceipt>\n      }))\n    }\n    return this.sendMessage(this.prepareMessage(content, roomId)) as Promise<IMessageReceipt>\n  }\n\t/**\n\t * Prepare and send string/s to specified room name (or ID).\n\t * @param content Accepts message text string or array of strings.\n\t * @param room    A name (or ID) to resolve as ID to use in send.\n\t */\n  sendToRoom (\n\tcontent: string | string[] | IMessage,\n\troom: string\n): Promise<IMessageReceipt[] | IMessageReceipt> {\n    return this.getRoomId(room)\n\t\t.then((roomId) => this.sendToRoomId(content, roomId))\n  }\n\n\t/**\n\t * Prepare and send string/s to a user in a DM.\n\t * @param content   Accepts message text string or array of strings.\n\t * @param username  Name to create (or get) DM for room ID to use in send.\n\t */\n  sendDirectToUser (\n\tcontent: string | string[] | IMessage,\n\tusername: string\n): Promise<IMessageReceipt[] | IMessageReceipt> {\n    return this.getDirectMessageRoomId(username)\n\t\t.then((rid) => this.sendToRoomId(content, rid))\n  }\n/**\n * Get ID for a DM room by its recipient's name.\n * Will create a DM (with the bot) if it doesn't exist already.\n * @todo test why create resolves with object instead of simply ID\n */\n  getDirectMessageRoomId (username: string): Promise<string> {\n    return this.createDirectMessage(username).then((DM: any) => DM.rid)\n  }\n\n  getRoomNameById (rid: string) {\n    return this.getRoomName(rid)\n  }\n}\n"]}