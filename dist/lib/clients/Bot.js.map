{"version":3,"file":"Bot.js","sourceRoot":"","sources":["../../../src/lib/clients/Bot.ts"],"names":[],"mappings":"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","sourcesContent":["import { Message } from '../message'\nimport { logger } from '../log'\nimport { Protocols, ISocket, IDriver } from '../drivers'\nimport Rocketchat from './Rocketchat'\nimport {\n\tILogger,\n\tISocketOptions,\n\tIRespondOptions,\n\tICallback,\n\tIMessageCallback,\n\tISubscriptionEvent,\n\tIMessage,\n\tIMessageMeta,\n\tIMessageReceipt,\n\tISubscription,\n\tICredentials,\n\tILoginResult,\n\tIRoomResultAPI\n} from '../../interfaces'\nimport { RID } from '../api/RocketChat'\n\nconst MY_MESSAGES = '__my_messages__'\nconst TOPIC_MESSAGES = 'stream-room-messages'\n\nexport default class BotClient extends Rocketchat {\n  integrationId: string\n  lastReadTime: Date = new Date(-8640000000000000)\n  joinedIds: string[] = []\n  messages: ISubscription | null = null\n\n  constructor ({ integrationId, ...config }: any) {\n    super(config)\n    this.integrationId = integrationId\n  }\n\n  async login (credentials: ICredentials) {\n    await super.login(credentials)\n    return this.currentLogin && (await this.socket as IDriver).login({ token: this.currentLogin.authToken } as any, {})\n  }\n\t/**\n\t * Initialise socket instance with given options or defaults.\n\t * Proxies the DDP module socket connection. Resolves with socket when open.\n\t * Accepts callback following error-first-pattern.\n\t * Error returned or promise rejected on timeout.\n\t * @example <caption>Use with callback</caption>\n\t *  import driver from '@rocket.chat/sdk/bot'\n\t *  driver.connect({}, (err) => {\n\t *    if (err) throw err\n\t *    else console.log('connected')\n\t *  })\n\t * @example <caption>Using promise</caption>\n\t *  import driver from '@rocket.chat/sdk/bot'\n\t *  driver.connect()\n\t *    .then(() => console.log('connected'))\n\t *    .catch((err) => console.error(err))\n\t */\n  async connect (options: ISocketOptions, callback?: ICallback): Promise<any> {\n    try {\n      const result = await (await this.socket as ISocket).connect(options)\n      if (callback) {\n        callback(null, result)\n      }\n      return result\n\n    } catch (error) {\n      if (callback) {\n        callback(error, null)\n        return Promise.reject(error)\n      }\n    }\n  }\n/** Begin subscription to user's \"global\" message stream. Will only allow one. */\n  async subscribeToMessages () {\n    if (!this.messages) {\n      this.messages = await this.subscribe(TOPIC_MESSAGES, MY_MESSAGES)\n    }\n    return this.messages\n  }\n/**\n * Add callback for changes in the message stream, subscribing if not already.\n * This can be called directly for custom extensions, but for most usage (e.g.\n * for bots) the respondToMessages is more useful to only receive messages\n * matching configuration.\n *\n * @param callback Function called with every change in subscriptions.\n *  - Uses error-first callback pattern\n *  - Second argument is the changed message\n *  - Third argument is additional attributes, such as `roomType`\n */\n  async reactToMessages (callback: IMessageCallback) {\n    const handler = (e: ISubscriptionEvent) => {\n      try {\n        const message: IMessage = e.fields.args[0]\n        if (!message || !message._id) {\n          callback(new Error('Message handler fired on event without message or meta data'))\n        } else {\n          callback(null, message, {} as any)\n        }\n      } catch (err) {\n        this.logger.error(`[driver] Message handler err: ${err.message}`)\n        callback(err)\n      }\n    }\n    this.messages = await this.subscribeToMessages()\n\n    this.messages.onEvent(handler)\n\n    this.logger.info(`[driver] Added event handler for ${this.messages!.name} subscription`)\n  }\n/**\n * Applies `reactToMessages` with some filtering of messages based on config.\n * If no rooms are joined at this point, it will attempt to join now based on\n * environment config, otherwise it might not receive any messages. It doesn't\n * matter that this happens asynchronously because joined rooms can change after\n * the subscription is set up.\n *\n * @param callback Function called after filters run on subscription events.\n *  - Uses error-first callback pattern\n *  - Second argument is the changed item\n *  - Third argument is additional attributes, such as `roomType`\n * @param options Sets filters for different event/message types.\n */\n  async respondToMessages (callback: IMessageCallback, options: IRespondOptions = {}) {\n    const config = { ...this.config, ...options }\n\n\t\t// Join configured rooms if they haven't been already, unless listening to all\n\t\t// public rooms, in which case it doesn't matter\n    if (!config.allPublic && this.joinedIds.length === 0 && config.rooms && config.rooms.length > 0) {\n      try {\n        await this.joinRooms(config.rooms)\n      } catch (err) {\n        this.logger.error(`[driver] Failed to join configured rooms (${config.rooms.join(', ')}): ${err.message}`)\n      }\n    }\n\n    this.lastReadTime = new Date() // init before any message read\n    return this.reactToMessages(async (err, message, meta) => {\n      if (err) {\n        logger.error(`[driver] Unable to receive: ${err.message}`)\n        return callback(err) // bubble errors back to adapter\n      }\n      if (typeof message === 'undefined' || typeof meta === 'undefined') {\n        logger.error(`[driver] Message or meta undefined`)\n        return callback(err)\n      }\n\n\t\t\t// Ignore bot's own messages\n      if (message.u && message.u._id === this.userId) return\n\n\t\t\t// Ignore DMs unless configured not to\n      const isDM = meta.roomType === 'd' || true\n      if (isDM && !config.dm) return\n\n\t\t\t// Ignore Livechat unless configured not to\n      const isLC = meta.roomType === 'l'\n\n      if (isLC && !config.livechat) return\n\n\t\t\t// Ignore messages in un-joined public rooms unless configured not to\n      if (!config.allPublic && !isDM && !meta.roomParticipant) return\n\n\t\t\t// Set current time for comparison to incoming\n      let currentReadTime = (message.ts) ? new Date(message.ts.$date) : new Date()\n\n\t\t\t// Ignore edited messages if configured to\n      if (!config.edited && typeof message.editedAt !== 'undefined') return\n\n\t\t\t// Ignore messages in stream that aren't new\n      if (currentReadTime <= this.lastReadTime) return\n\n\t\t\t// At this point, message has passed checks and can be responded to\n      const username = (message.u) ? message.u.username : 'unknown'\n      this.logger.info(`[driver] Message ${message._id} from ${username}`)\n      this.lastReadTime = currentReadTime\n      callback(null, message, meta)\n    })\n  }\n\n\t/** Get ID for a room by name (or ID). */\n  getRoomId (name: string): Promise<RID> {\n    return this.getRoomIdByNameOrId(name)\n  }\n\n/** Get name for a room by ID. */\n  getRoomName (rid: RID): Promise<string> {\n    return super.getRoomNameById(rid)\n  }\n\n\t/** Join the bot into a room by its name or ID */\n  async joinRoom (room: string): Promise<RID> {\n    const roomId = await this.getRoomId(room)\n    const joinedIndex = this.joinedIds.indexOf(room)\n    if (joinedIndex !== -1) {\n      logger.error(`[driver] Join room failed, already joined`)\n      throw new Error(`[driver] Join room failed, already joined`)\n    }\n    await super.joinRoom(roomId)\n    this.joinedIds.push(roomId)\n    return roomId\n  }\n\n\t/** Exit a room the bot has joined */\n  async leaveRoom (room: string): Promise<RID> {\n    let roomId = await this.getRoomId(room)\n    let joinedIndex = this.joinedIds.indexOf(room)\n    if (joinedIndex === -1) {\n      this.logger.error(`[driver] Leave room failed, bot has not joined ${room}`)\n      throw new Error(`[driver] Leave room failed, bot has not joined ${room}`)\n    }\n    await this.leaveRoom(roomId)\n    delete this.joinedIds[joinedIndex]\n    return roomId\n  }\n\n\t/** Join a set of rooms by array of names or IDs */\n  joinRooms (rooms: string[]): Promise < RID[] > {\n    return Promise.all(rooms.map((rid) => this.joinRoom(rid)))\n  }\n\t/**\n\t * Prepare and send string/s to specified room ID.\n\t * @param content Accepts message text string or array of strings.\n\t * @param roomId  ID of the target room to use in send.\n\t * @todo Returning one or many gets complicated with type checking not allowing\n\t *       use of a property because result may be array, when you know it's not.\n\t *       Solution would probably be to always return an array, even for single\n\t *       send. This would be a breaking change, should hold until major version.\n\t */\n  sendToRoomId (content: string | string[] | IMessage, roomId: string): Promise < IMessageReceipt[] | IMessageReceipt > {\n    if (Array.isArray(content)) {\n      return Promise.all(content.map((text) => {\n        return this.sendMessage(this.prepareMessage(text, roomId)) as Promise<IMessageReceipt>\n      }))\n    }\n    return this.sendMessage(this.prepareMessage(content, roomId)) as Promise<IMessageReceipt>\n  }\n\t/**\n\t * Prepare and send string/s to specified room name (or ID).\n\t * @param content Accepts message text string or array of strings.\n\t * @param room    A name (or ID) to resolve as ID to use in send.\n\t */\n  sendToRoom (content: string | string[] | IMessage, room: string): Promise < IMessageReceipt[] | IMessageReceipt > {\n    return this.getRoomId(room)\n\t\t.then((roomId) => this.sendToRoomId(content, roomId))\n  }\n\n\t/**\n\t * Prepare and send string/s to a user in a DM.\n\t * @param content   Accepts message text string or array of strings.\n\t * @param username  Name to create (or get) DM for room ID to use in send.\n\t */\n  sendDirectToUser (content: string | string[] | IMessage, username: string): Promise < IMessageReceipt[] | IMessageReceipt > {\n    return this.getDirectMessageRoomId(username)\n\t\t.then((rid) => this.sendToRoomId(content, rid))\n  }\n\t/**\n\t * Get ID for a DM room by its recipient's name.\n\t * Will create a DM (with the bot) if it doesn't exist already.\n\t * @todo test why create resolves with object instead of simply ID\n\t */\n  getDirectMessageRoomId (username: string): Promise <RID> {\n    return this.createDirectMessage(username).then((DM: any) => {\n      return DM._id\n    })\n  }\n\n  getRoomNameById (rid: string) {\n    return this.getRoomName(rid)\n  }\n}\n"]}